package service

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/goharbor/harbor/src/pkg/project/models"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/goharbor/harbor/src/pkg/scan/vuln"

	"github.com/ppxl/harbor-cve-finder/pkg/core"
)

const harborApiVersion = "/api/v2.0"

type FindService struct {
	args core.FindArgs
}

func New(args core.FindArgs) *FindService {
	return &FindService{args: args}
}

func (fs *FindService) GetProjectInfo(ctx context.Context) ([]core.ProjectSummary, error) {
	projects, err := fs.getProjects(ctx)
	if err != nil {
		return nil, err
	}

	if len(fs.args.OnlyProjects) > 0 {
		projects = []core.HarborProject{}
		for _, proj := range fs.args.OnlyProjects {
			projects = append(projects, core.HarborProject{Project: models.Project{Name: proj}})
		}
	}

	var projSums []core.ProjectSummary

	for _, proj := range projects {
		repos, err := fs.getReposByProject(ctx, proj)
		if err != nil {
			return nil, err
		}

		_, err = fs.getRepoSummaries(ctx, proj.Name, repos)
		if err != nil {
			return nil, err
		}

	}

	return projSums, nil
}

func (fs *FindService) getRepoSummaries(ctx context.Context, projectName string, repos []core.HarborRepository) ([]core.RepoSummary, error) {
	var repoSums []core.RepoSummary

	for _, repo := range repos {
		repoName := strings.Replace(repo.Name, projectName+"/", "", 1)
		fmt.Printf("Looking at %s/%s\n", projectName, repoName)
		artifacts, err := fs.getArtifactsForRepo(ctx, projectName, repoName)
		if err != nil {
			return nil, err
		}

		tags, err := fs.getTagsForArtifact(ctx, projectName, repoName, artifacts)
		if err != nil {
			return nil, err
		}

		for _, tag := range tags {
			cveReport, err := fs.findVulnReports(ctx, projectName, repoName, tag)
			if err != nil {
				return nil, fmt.Errorf("failed to vuln report for artifact %s: %w", tag.Name, err)
			}
			if cveReport != nil {
				for _, foundVuln := range cveReport.ApplicationVndSecurityVulnerabilityReportVersion11.Vulnerabilities {
					if foundVuln.Severity == vuln.High.String() || foundVuln.Severity == vuln.Critical.String() {
						lowerExp := strings.ToLower(fs.args.PackageExpression)
						if strings.Contains(foundVuln.Package, lowerExp) {
							fmt.Printf("Found vuln in %s/%s:%s: %s in package %s\n", projectName, repoName, tag.Name, foundVuln.ID, foundVuln.Package)
						}
					}
				}
			}
		}
	}

	return repoSums, nil
}

func (fs *FindService) getTagsForArtifact(ctx context.Context, projectName string, repoName string, artifacts []core.HarborArtifact) ([]core.Tag, error) {
	tags := []core.Tag{}

	for _, arti := range artifacts {
		endpoint := fmt.Sprintf("/projects/%s/repositories/%s/artifacts/%s/tags", projectName, repoName, arti.Digest)
		response, err := fs.createAuthdGetRequest(ctx, endpoint)
		if err != nil {
			return nil, fmt.Errorf("failed to request artifact for project %s repo %s: %w", projectName, repoName, err)
		}
		body, err := io.ReadAll(response.Body)
		defer response.Body.Close()
		if err != nil {
			return nil, fmt.Errorf("failed to read body of request to %s: %w", endpoint, err)
		}

		foundTags := []core.Tag{}
		err = json.Unmarshal(body, &foundTags)
		if err != nil {
			if strings.Contains(string(body), "NOT_FOUND") {
				foundTags = append(foundTags, core.Tag{Name: "no_tag_found", ArtifactDigest: arti.Digest})
				continue
			}
			return nil, fmt.Errorf("failed to unmarshal tag for project %s repo %s digest: %s: %s: %w", projectName, repoName, arti.Digest, body, err)
		}

		for i := range foundTags {
			foundTags[i].ArtifactDigest = arti.Digest
		}

		tags = append(tags, foundTags...)
	}

	return tags, nil
}

func (fs *FindService) findVulnReports(ctx context.Context, projectName string, repoName string, tag core.Tag) (*core.CveReport, error) {
	endpoint := fmt.Sprintf("/projects/%s/repositories/%s/artifacts/%s/additions/vulnerabilities", projectName, repoName, tag.ArtifactDigest)
	response, err := fs.createAuthdGetRequest(ctx, endpoint)
	if err != nil {
		return nil, fmt.Errorf("failed to request artifact for project %s repo %s: %w", projectName, repoName, err)
	}

	body, err := io.ReadAll(response.Body)
	defer response.Body.Close()
	if err != nil {
		return nil, fmt.Errorf("failed to read body of request to %s: %w", endpoint, err)
	}

	report := core.CveReport{}
	err = json.Unmarshal(body, &report)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal CVE report for project %s repo %s tag: %s: %s: %w", projectName, repoName, tag.Name, body, err)
	}

	return &report, nil
}

func (fs *FindService) getArtifactsForRepo(ctx context.Context, projectName string, repoName string) ([]core.HarborArtifact, error) {
	repoName = escapeSlashes(repoName)
	endpoint := fmt.Sprintf("/projects/%s/repositories/%s/artifacts?page=1&page_size=100&with_tag=true", projectName, repoName)
	response, err := fs.createAuthdGetRequest(ctx, endpoint)
	if err != nil {
		return nil, fmt.Errorf("failed to request artifact for project %s repo %s: %w", projectName, repoName, err)
	}

	body, err := io.ReadAll(response.Body)
	defer response.Body.Close()
	if err != nil {
		return nil, fmt.Errorf("failed to read body of request to %s: %w", endpoint, err)
	}
	var artifacts []core.HarborArtifact
	err = json.Unmarshal(body, &artifacts)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal artifact for project %s repo %s: %s: %w", projectName, repoName, body, err)
	}

	return artifacts, nil
}

func (fs *FindService) getProjects(ctx context.Context) ([]core.HarborProject, error) {
	const endpoint = "/projects?page=1&page_size=100&with_detail=false"
	response, err := fs.createAuthdGetRequest(ctx, endpoint)
	if err != nil {
		return nil, fmt.Errorf("failed to request projects: %w", err)
	}

	body, err := io.ReadAll(response.Body)
	defer response.Body.Close()
	if err != nil {
		return nil, fmt.Errorf("failed to read body of request to %s: %w", endpoint, err)
	}
	var projects []core.HarborProject
	err = json.Unmarshal(body, &projects)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal projects %s: %w", body, err)
	}

	return projects, nil
}

func (fs *FindService) getReposByProject(ctx context.Context, prj core.HarborProject) ([]core.HarborRepository, error) {
	endpoint := "/projects/" + prj.Name + "/repositories?page=1&page_size=100"
	response, err := fs.createAuthdGetRequest(ctx, endpoint)
	if err != nil {
		return nil, fmt.Errorf("repo request failed for endpoint /projects/%s/repositories: %w", prj.Name, err)
	}

	body, err := io.ReadAll(response.Body)
	defer response.Body.Close()
	if err != nil {
		return nil, fmt.Errorf("failed to read body of request to %s: %w", endpoint, err)
	}
	var repoList []core.HarborRepository
	err = json.Unmarshal(body, &repoList)
	if err != nil {
		return nil, fmt.Errorf("failed to to unmarshal %s repo data %s: %w", prj.Name, string(body), err)
	}

	// debug
	//fmt.Printf("Found %s repo counts:", prj.Name)
	//for _, repo := range repoList {
	//	fmt.Printf(" %s: %d, ", repo.Name, repo.ArtifactCount)
	//}
	//fmt.Println()

	return repoList, nil
}

func (fs *FindService) createAuthdGetRequest(ctx context.Context, endpoint string) (*http.Response, error) {
	theUrl, err := url.JoinPath(fs.args.HarborURL, harborApiVersion)
	if err != nil {
		return nil, fmt.Errorf("could not parse harbor URL with these fragments: %s, %s, %s: %w", fs.args.HarborURL, harborApiVersion, err)
	}
	theUrl += endpoint

	request, err := http.NewRequestWithContext(ctx, http.MethodGet, theUrl, nil)
	if err != nil {
		return nil, err
	}
	request.Header.Add("Authorization", "Basic "+basicAuth(fs.args.Credentials.Username, fs.args.Credentials.Password))
	request.Header.Add("accept", "application/json")

	response, err := http.DefaultClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("request to theUrl failed: %w", err)
	}

	// debug log
	//fmt.Println("GET", theUrl, "result:", response.Body)
	return response, nil
}

func escapeSlashes(name string) string {
	// this should only be the case when harbor returns repositories with multiple slashes like project/repo/thing.
	return strings.ReplaceAll(name, "/", "%252F")
}

func basicAuth(username, password string) string {
	auth := username + ":" + password
	return base64.StdEncoding.EncodeToString([]byte(auth))
}
